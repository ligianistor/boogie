// Flyweight is often combined with Composite to implement shared leaf nodes.
// Taken from https://sourcemaking.com/design_patterns/flyweight

// Instances of College will be the Flyweights
class College {
  private final int collegeNumber; // this is the sharable state
 // private int campusNumber; // this is the non-sharable, that is provided by the client
// when it calls a method on the college. It shouldn't be a field, it is provided in the calling method.

  College(int number) {
    this.collegeNumber = number;
  }

 Integer getFraternities() {
	return new Integer(collegeNumber * 2);
}	// The number of fraternities is an invariant of each flyweight object.

// We need to know the campusNumber in order to get the return from this 
// method.
// I could have used "switch" but we don't have support for it.
  int getNumberFacilities(int campusNumber) {
	if (campusNumber mod 2 == 0)
		return campusNumber * 2 + 1;
        } else return campusNumber * 3;
 }
}
-----------------
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

// ListOfAvailableColleges acts as a factory and cache for College flyweight objects
// The client must use this class in order to create "new" College objects
class ListOfAvailableColleges {
  private Map<Integer, College> listOfColleges = new ConcurrentHashMap<Integer, College>();

  College lookup(int collegeNumber) {
    if (!listOfColleges.containsKey(collegeNumber))
      listOfColleges.put(collegeNumber, new College(collegeNumber));
    return listOfColleges.get(collegeNumber);
  }

}
---------------------------

class StudentApplication {
  private final College college; //intrinsic state
  private int campusNumber; // extrinsic information

  StudentApplication(College college, int campusNumber) {
    this.college = college;
    this.campusNumber = campusNumber;
  }

  int getNumberFacilities() {
	return college.getNumberFacilities(campusNumber);
  }

 Integer getFraternities() {
	return college.getFraternities();
}
}
--------------------------------

class OriginHighschool {
  private StudentApplication studentApp;

OriginHighschool(StudentApplication studentApp_) {
	studentApplication = studentApplication_;
}

// has as precondition that studentApp.getFraternities() should be a multiple of 2
boolean getFraternitiesCollege() {
	if (studentApp.getFraternities() % 2) {
		return true;	
	} else {
		return false;
	} 
}

}

-------------------------------


import java.util.List;
import java.util.Vector;

public class ApplicationWebsite {
  private final List<StudentApplication> listStudentApplications = new Vector<StudentApplication>();
  private final ListOfAvailableColleges listOfAvailableColleges = new ListOfAvailableColleges();

// Each student application is submitted for a college, but the student can choose which campus of that college
// he or she wants to go to.
  Integer submitApplicationGetFacilities(int collegeNumber, int campusNumber) {
    College college = listOfAvailableColleges.lookup(collegeNumber);
    StudentApplication studentApplication = new StudentApplication(college, campusNumber);
    listStudentApplications.add(studentApplication);
    return new Integer(studentApplication.getNumberFacilities());
  }

  public static void main(String[] args) {
    ApplicationWebsite website = new ApplicationWebsite();

    // All these applications are for college number 2, but for different campuses.
    // They will have the invariant that college number 2 offers, 
    // but will offer slightly different facilties.
    // Instead of the returned "facilities" 1 it can be an Integer() object
    // so I could write an object proposition about it.
    Integer facilities1 = website.submitApplicationGetFacilities(2, 1); 
    Integer facilities2 = website.submitApplicationGetFacilities(2, 2);
    Integer facilities3 = website.submitApplicationGetFacilities(2, 3);

// Here I could use listOfAvailableColleges to lookup a college and assert a property about it.

// I need to state some properties about facilities1, 2 3.

    // The 3 lines below show the difference between object propositions
    // and classical invariants. 
    // We can have 2 instances of College but with different college numbers and hence with different invariants.

    Integer facilities4 = website.submitApplicationGetFacilities(3, 1); 
    Integer facilities5 = website.submitApplicationGetFacilities(3, 2);
    Integer facilities6 = website.submitApplicationGetFacilities(3, 3);
------------------------------------------
 // A simpler client that does not use the class ApplicationWebsite
 // but instead uses all the other classes. The idea is the same in principle, whether we use ApplicationWebsite or not.
College college = new College(1);
StudentApplication app1 = new Studentapplication(college, 1);
Studentapplication app2 = new StudentApplication(college, 2);
OriginHighschool high1 = new OriginHighschool(app1);
OriginHighschool high2 = new OriginHighschool(app2);

high1.getFraternitiesCollege();
high2.getFraternitiesCollege();

// This client code should verify
// by basing itself on the invariant predicate that the College object provides.
  }
}

