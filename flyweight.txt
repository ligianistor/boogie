// Flyweight is often combined with Composite to implement shared leaf nodes.
// Taken from https://sourcemaking.com/design_patterns/flyweight

// Instances of College will be the Flyweights
class College {
  private final int collegeNumber; // this is the sharable state
 // private int campusNumber; // this is the non-sharable, that is provided by the client
// when it calls a method on the college. It shouldn't be a field, it is provided in the calling method.

  College(int number) {
    this.collegeNumber = number;
  }

// We need to know the campusNumber in order to get the return from this 
// method.
// I could have used "switch" but we don't have support for it.
  int getNumberFacilities(int campusNumber) {
	if (campusNumber == 1) {
		return 3;
        } else if (campusNumber == 2) {
		return 4;
        } else return 5;
 }
}
-----------------
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

// ListOfAvailableColleges acts as a factory and cache for College flyweight objects
// The client must use this class in order to create "new" College objects
class ListOfAvailableColleges {
  private Map<Integer, College> listOfColleges = new ConcurrentHashMap<Integer, College>();

  College lookup(int collegeNumber) {
    if (!listOfColleges.containsKey(collegeNumber))
      listOfColleges.put(collegeNumber, new College(collegeNumber));
    return listOfColleges.get(collegeNumber);
  }

  int totalAvailableColleges() {
    return listOfColleges.size();
  }
}
---------------------------

class StudentApplication {
  private final int studentNumber;
  private final College college;
  private int campusNumber;

  StudentApplication(int studentNumber, College college, int campusNumber) {
    this.studentNumber = studentNumber;
    this.college = college;
    this.campusNumber = campusNumber;
  }

  int getNumberFacilitiesOfCollege() {
	return college.getNumberFacilities(campusNumber);
  }
}
--------------------------------


import java.util.List;
import java.util.Vector;

public class ApplicationWebsite {
  private final List<StudentApplication> listStudentApplications = new Vector<StudentApplication>();
  private final ListOfAvailableColleges listOfAvailableColleges = new ListOfAvailableColleges();

// TODO do I need studentNumber?
// it does not seem to be used!
// Same with report() method below.
  int submitApplicationGetFacilities(int studentNumber, int collegeNumber, int campusNumber) {
    College college = listOfAvailableColleges.lookup(collegeNumber);
    StudentApplication studentApplication = new StudentApplication(studentNumber, college, campusNumber);
    listStudentApplications.add(studentApplication);
    return studentApplication.getNumberFacilitiesOfCollege();
  }

  int report() {
	  //System.out.println(listOfAvailableColleges.totalAvailableColleges());
    return listOfAvailableColleges.totalAvailableColleges();
  }

  public static void main(String[] args) {
    ApplicationWebsite website = new ApplicationWebsite();

    // All these applications are for college number 2, but for different campuses.
    // They will have the invariant that college number 2 offers, 
    // but will offer slightly different facilties.
    // Instead of the returned "facilities" 1 it can be an Integer() object
    // so I could write an object proposition about it.
    int facilities1 = website.submitApplicationGetFacilities(1, 2, 1); 
    int facilities2 = website.submitApplicationGetFacilities(2, 2, 2);
    int facilities3 = website.submitApplicationGetFacilities(3, 2, 3);

//I need to state some properties about facilities1, 2 3.

    // The 3 lines below show the difference between object propositions
    // and classical invariants. 
    // We can have 2 instances of College but with different college numbers and hence with different invariants.

    int facilities4 = website.submitApplicationGetFacilities(1, 3, 1); 
    int facilities5 = website.submitApplicationGetFacilities(2, 3, 2);
    int facilities6 = website.submitApplicationGetFacilities(3, 3, 3);
  }
}

