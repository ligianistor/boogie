
class IntCell {

predicate HigherThanZero() = value->v && v>0
predicate MultipleOf6(int n) = value->v && (v == n * 6)
predicate MultipleOf15(int n) = value->v && (v == n * 15)
predicate MultipleOf3(int n) = value->v && (v == n * 3)

int value;
IntCell(int x) {
	value  = x;
}

void setValue(int x) {
	value = x;
}

int getValue() {
	return value;
}

}


interface Statelike {
	final static IntCell cell =  new IntCell(3);    
	void computeResult(StateContext context, int num); 
}

class StateMultiplySix implements Statelike {

	predicate StateMultipleOf6(int n) = cell -> c && c@1 MultipleOf6(n)

    @Override
	-> this@1 StateMultipleOfSix(num) && context@1 state15()
    public void computeResult(final StateContext context, final int num) {
        context.setState(new StateMultiplyFifteen());
	cell.setValue(num*6);
    }
    
}

class StateMultiplyFifteen implements Statelike {
    /** Counter local to this state */
	predicate StateMultipleOf15(int n) = cell ->c && c@1 MultipleOf15(n)
	predicate CountGt1() = count > 1
	predicate CountLe1() = count <= 1

    private int count = 0;

    @Override
//We cannot know statically the value of count, so we can't know for 
//sure which way the "if"" will go.
//In this case the assertion at the end will be less strong.
//Predicate CountGt1() is the negation of CountLe1().
//Another example can be without "if"
	-> this@1 StateMultipleOf15(num) &&  
	((CountGt1() -> context@1 state6()) || (CountLe1() -> context@1 state15()))
    public void computeResult(final StateContext context, final int num) {
        /* Change state after StateMultiplyFifteen's computeResult() gets invoked twice */
        if(++count > 1) {
            context.setState(new StateMultiplySix());
        }
	cell.setValue(num*15);
    }
    
}

--------------
class StateContext {
    private Statelike myState;

predicate state6() = myState instanceof StateMultiplySix
predicate state15() = myState instanceof StateMultiplyFifteen
predicate stateContextMultiple6(int num) = myState@1 StateMultipleOf6(num)
predicate stateContextMultiple15(int num) = myState@1 StateMultipleOf15(num)

	-> state6()
    StateContext() {
        setState(new StateMultiplySix());
    }

    /**
     * Setter method for the state.
     * Normally only called by classes implementing the State interface.
     * @param newState the new state of this context
     */
    void setState(final Statelike newState) {
        myState = newState;
    }

-> (this@1 state6() -> this@1 stateContextMultiple6(num))
&&
(this@1 state15() -> this@1 stateContextMultiple15(num))

    public void computeResult(final int num) {
        myState.computeResult(this, num);
    }
}
---------------------
public class DemoOfClientState {
    public static void main(String[] args) {
        final StateContext sc = new StateContext();
{sc@1 state6()}
	int result = 0;

        sc.computeResult(1);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(2);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(3);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(4);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(5);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(6);
	result = result + sc.getIntCellStatelike();
        sc.computeResult(7);
	result = result + sc.getIntCellStatelike();
	//assert result satisfies MultipleOf3
//TODO remove that if that makes this program be difficult
//Maybe need to wrap result in IntCell.
    }
}
-------------

